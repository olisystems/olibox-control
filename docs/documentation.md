# The Joy of Writing Snaps for Python Apps

Snap is a universal Linux package format having both the command line interface and the application package format. The snap offers a single packaging format to create new applications with all the dependencies while ensuring that the newly created applications are easily shareable between the distributions.

In this tutorial, we are going to create a snap for a python application. The application will take user input to set up an MQTT connection. Then we will subscribe to channels to receive messages and finally, the messages will be saved to a JSON file. 

A brief description of the major modules of the app are as follows:

1. The config module (`config.py`): we will use python [click](https://click.palletsprojects.com/en/7.x/) package to get the user input. The user input will be saved into a TOML file.

2. The MQTT module (`oli_mqtt`): This module will set up an MQTT connection and subscribe to channels. The response will be saved into a JSON file.

3. The control module (`olibox_control`): This is the main module that will call the functionality from other modules.


## 1. Python App Skeleton

First, we will design the said functionality within the python application, without implementing any snap configuration. The application has a basic python app structure as follows:

```
.
├── ca-certificates.crt
├── docs
│   └── documentation.md
├── LICENSE
├── olibox_control
│   ├── control_pkg
│   │   ├── config.py
│   │   ├── helpers.py
│   │   ├── __init__.py
│   │   └── oli_mqtt.py
│   ├── __init__.py
│   └── olibox_control.py
├── README.md
├── requirements.txt
├── setup.py
└── tests
    └── oliboxcontrol_tests.py
```

We will add some necessary modules later on as required.
### 1.1 The Configuration Module

The configuration module uses python click package to take the user input to configure the MQTT connection and to subscribe the topics. These configuration are save inside `config.toml` file that will be read out by `environments.py` module. 

A sample `config.toml` will look like this:

```
title = "OLI Box Config"

[mqtt_connection]
mqtt_broker_ip = "unbelievable-politician.cloudmqtt.com"
mqtt_broker_port = "8883"
ssl_cert_path = "ca-certificates.crt"
mqtt_username = "gmnzhypg"
mqtt_password = "s"

[topic_config]
project_id = "dose"
oli_box_id = "6"
dest_type = "chargingStation"
command = "setChargingLimit"
```

### 1.2 The Environment Module

The environment module reads the `toml` file generated by `config` module and saves the user inputs to `locals`. The `locals` are symbol table that stores all the information defined in the local namespace of the program. `locals` are then can be accessed using `locals()` method which returns dictionary associated with the current symbol table. 

We are going to use `toml.load()` method which parse a file or a list of files as `TOML` and returns a dictionary. As of a result of `toml.load()` method, we will get a nested dictionary. In order to get all the values out of nested dictionary, we will loop through all the dictionary items.

First we will retrieve all the items of nested dictionary and 'll check their type (either they are key value pairs or dictionaries). From the above mentioned `config.toml` file, we would get following items and their types. The output of the print (`print(item, type(f[item]), json.dumps(f[item], indent=2), '\n')`) statement is:

```
title <class 'str'> "OLI Box Config" 

mqtt_connection <class 'dict'> {
  "mqtt_broker_ip": "unbelievable-politician.cloudmqtt.com",
  "mqtt_broker_port": "8883",
  "ssl_cert_path": "ca-certificates.crt",
  "mqtt_username": "gmnzhypg",
  "mqtt_password": "s"
} 

topic_config <class 'dict'> {
  "project_id": "dose",
  "oli_box_id": "6",
  "dest_type": "chargingStation",
  "command": "setChargingLimit"
} 

```
From the above snippet, we can see that some items are not the simple key value pair but are dictionaries. So we need to loop through the dictionaries to get their items as well.

In order to hold the unique key value pairs from all the nested dictionaries, we declare an enmpty dictionary (`unique_dict = {}`). Next we will use a `for` loop to loop through all the keys to check either they are strings or dictionaries. In case they are dictionaries, then get their items and append them to our `unique_dict`. Also simply append the strings to `unique_dict`. The following code snippet is doing the job for us:

```
if type(f[item]) is not str:
    for i in f[item].keys():
        unique_dict[i] = f[item][i]
else:
    unique_dict[item] = f[item]
                    
```

Finally, we will update `locals` with `unique_dict` to make them available in local namespace for the program.



### References
* https://linuxconfig.org/a-beginner-s-introduction-to-snaps-the-universal-linux-package-format